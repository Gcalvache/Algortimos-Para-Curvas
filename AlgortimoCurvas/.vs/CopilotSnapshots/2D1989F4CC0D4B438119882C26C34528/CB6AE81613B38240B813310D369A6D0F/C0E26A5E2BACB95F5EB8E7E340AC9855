using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;

namespace AlgortimoCurvas
{
    public partial class frmCurvaB_Spline : Form
    {
        private List<PointF> controlPoints = new List<PointF>();
        private List<PointF> curvePoints = new List<PointF>();

        private int selectedPointIndex = -1;
        private bool isDragging = false;

        // Default number of samples for curve rendering
        private int defaultSamples = 200;

        // New: mode to add points when enabled
        private bool addPointMode = false;

        // New: dragging entire curve
        private bool draggingCurve = false;
        private PointF lastMousePos;

        public frmCurvaB_Spline()
        {
            InitializeComponent();
            // Ensure button initial text reflects mode off
            btnAddOnCurve.Text = "Nuevo punto (en curva)";
        }

        private void RecalcularCurva()
        {
            if (controlPoints.Count >= 2)
            {
                int degree = (int)nudDegree.Value;
                curvePoints = CCurva.EvaluarCurva(controlPoints, degree, defaultSamples);
            }
            else
            {
                curvePoints.Clear();
            }
            picCanvas.Invalidate();
        }

        private void picCanvas_MouseDown(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
            {
                if (addPointMode)
                {
                    // Insert a new control point at click location (best insert index)
                    int insertIndex = FindBestInsertIndex(new PointF(e.X, e.Y));
                    if (insertIndex < 0) insertIndex = controlPoints.Count;
                    controlPoints.Insert(insertIndex, new PointF(e.X, e.Y));
                    selectedPointIndex = insertIndex;
                    isDragging = true; // allow immediate dragging
                    RecalcularCurva();
                    return;
                }

                int idx = GetPointAt(e.Location);
                if (idx >= 0)
                {
                    selectedPointIndex = idx;
                    isDragging = true;
                }
                else
                {
                    // If clicked near the curve, start dragging the whole curve
                    int curveIdx = GetCurvePointAt(e.Location);
                    if (curveIdx >= 0 && curvePoints != null && curvePoints.Count > 0)
                    {
                        draggingCurve = true;
                        lastMousePos = e.Location;
                    }
                    else
                    {
                        // Click in empty space: add a new control point at that position
                        controlPoints.Add(e.Location);
                        selectedPointIndex = controlPoints.Count - 1;
                        isDragging = true;
                    }
                }
                RecalcularCurva();
            }
            else if (e.Button == MouseButtons.Right)
            {
                int idx = GetPointAt(e.Location);
                if (idx >= 0)
                {
                    controlPoints.RemoveAt(idx);
                    selectedPointIndex = -1;
                    RecalcularCurva();
                }
            }
        }

        private void picCanvas_MouseMove(object sender, MouseEventArgs e)
        {
            if (isDragging && selectedPointIndex >= 0 && selectedPointIndex < controlPoints.Count)
            {
                controlPoints[selectedPointIndex] = e.Location;
                RecalcularCurva();
            }
            else if (draggingCurve)
            {
                // Translate all control points by mouse delta
                float dx = e.X - lastMousePos.X;
                float dy = e.Y - lastMousePos.Y;
                if (Math.Abs(dx) > 0 || Math.Abs(dy) > 0)
                {
                    for (int i = 0; i < controlPoints.Count; i++)
                    {
                        controlPoints[i] = new PointF(controlPoints[i].X + dx, controlPoints[i].Y + dy);
                    }
                    lastMousePos = e.Location;
                    RecalcularCurva();
                }
            }
        }

        private void picCanvas_MouseUp(object sender, MouseEventArgs e)
        {
            if (isDragging || draggingCurve)
            {
                isDragging = false;
                selectedPointIndex = -1;
                draggingCurve = false;
                RecalcularCurva();
            }
        }

        private int GetPointAt(Point location)
        {
            const int hitRadius = 8;
            int idx = -1;
            double bestDist = double.MaxValue;
            for (int i = 0; i < controlPoints.Count; i++)
            {
                double dx = controlPoints[i].X - location.X;
                double dy = controlPoints[i].Y - location.Y;
                double d = dx * dx + dy * dy;
                if (d <= hitRadius * hitRadius && d < bestDist)
                {
                    bestDist = d;
                    idx = i;
                }
            }
            return idx;
        }

        private int GetCurvePointAt(Point location)
        {
            if (curvePoints == null || curvePoints.Count == 0) return -1;
            const int hitRadius = 6;
            int idx = -1;
            double bestDist = double.MaxValue;
            for (int i = 0; i < curvePoints.Count; i++)
            {
                double dx = curvePoints[i].X - location.X;
                double dy = curvePoints[i].Y - location.Y;
                double d = dx * dx + dy * dy;
                if (d <= hitRadius * hitRadius && d < bestDist)
                {
                    bestDist = d;
                    idx = i;
                }
            }
            return idx;
        }

        private void btnClear_Click(object sender, EventArgs e)
        {
            controlPoints.Clear();
            curvePoints.Clear();
            picCanvas.Invalidate();
        }

        private void btnAddOnCurve_Click(object sender, EventArgs e)
        {
            // Toggle add point mode
            addPointMode = !addPointMode;
            btnAddOnCurve.Text = addPointMode ? "Añadir punto: ON" : "Nuevo punto (en curva)";
            // Change cursor to indicate mode
            picCanvas.Cursor = addPointMode ? Cursors.Cross : Cursors.Default;
        }

        private int FindBestInsertIndex(PointF point)
        {
            // Find the control polygon segment whose midpoint is nearest to the given point
            if (controlPoints.Count < 2) return controlPoints.Count;
            double bestDist = double.MaxValue;
            int bestIndex = -1;
            for (int i = 0; i < controlPoints.Count - 1; i++)
            {
                var a = controlPoints[i];
                var b = controlPoints[i + 1];
                // Project point onto segment to get a better insert location
                var proj = ProjectPointOnSegment(point, a, b);
                double dx = proj.X - point.X;
                double dy = proj.Y - point.Y;
                double d = dx * dx + dy * dy;
                if (d < bestDist)
                {
                    bestDist = d;
                    bestIndex = i + 1;
                }
            }
            return bestIndex;
        }

        private PointF ProjectPointOnSegment(PointF p, PointF a, PointF b)
        {
            float vx = b.X - a.X;
            float vy = b.Y - a.Y;
            float wx = p.X - a.X;
            float wy = p.Y - a.Y;
            float denom = vx * vx + vy * vy;
            if (denom == 0) return a;
            float t = (vx * wx + vy * wy) / denom;
            t = Math.Max(0f, Math.Min(1f, t));
            return new PointF(a.X + t * vx, a.Y + t * vy);
        }

        private void picCanvas_Paint(object sender, PaintEventArgs e)
        {
            var g = e.Graphics;
            g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias;

            // Dibujar puntos de control
            for (int i = 0; i < controlPoints.Count; i++)
            {
                var p = controlPoints[i];
                var rect = new RectangleF(p.X - 5, p.Y - 5, 10, 10);
                g.FillEllipse(Brushes.Blue, rect);
                g.DrawEllipse(Pens.Black, rect);
            }

            // Dibujar líneas entre puntos de control
            if (controlPoints.Count >= 2)
            {
                g.DrawLines(Pens.Gray, controlPoints.ToArray());
            }

            // Dibujar curva si existe
            if (curvePoints != null && curvePoints.Count > 1)
            {
                g.DrawLines(Pens.Red, curvePoints.ToArray());
            }

            // Visual cue when in add point mode
            if (addPointMode)
            {
                // small info text
                using (var sf = new StringFormat())
                using (var brush = new SolidBrush(Color.FromArgb(200, Color.White)))
                using (var pen = new Pen(Color.Black))
                {
                    var text = "Modo añadir punto: Click para insertar";
                    var font = this.Font;
                    var size = g.MeasureString(text, font);
                    var rect = new RectangleF(10, picCanvas.Height - size.Height - 10, size.Width + 6, size.Height + 6);
                    g.FillRectangle(brush, rect);
                    g.DrawRectangle(pen, rect.X, rect.Y, rect.Width, rect.Height);
                    g.DrawString(text, font, Brushes.Black, rect.X + 3, rect.Y + 3);
                }
            }
        }

        private void nudDegree_ValueChanged(object sender, EventArgs e)
        {
            RecalcularCurva();
        }
    }
}

using System;
using System.Collections.Generic;
using System.Drawing;

namespace AlgortimoCurvas
{
    internal class CCurva
    {
        public static double[] GenerarNudosClamped(int cantidadPuntosControl, int grado)
        {
            if (cantidadPuntosControl <= 0) return new double[0];
            int n = cantidadPuntosControl - 1;
            int m = n + grado + 1;
            int longitudNudos = m + 1;

            double[] nudos = new double[longitudNudos];

            int repInicio = grado + 1;
            int repFin = grado + 1;

            if (longitudNudos <= repInicio + repFin)
            {
                for (int i = 0; i < longitudNudos; i++) nudos[i] = (i < repInicio) ? 0.0 : 1.0;
                return nudos;
            }

            int interiores = longitudNudos - repInicio - repFin;

            for (int i = 0; i < repInicio; i++) nudos[i] = 0.0;

            for (int i = 0; i < interiores; i++)
            {
                nudos[repInicio + i] = (double)(i + 1) / (interiores + 1);
            }

            for (int i = longitudNudos - repFin; i < longitudNudos; i++) nudos[i] = 1.0;

            return nudos;
        }

        public static PointF DeBoor(List<PointF> puntosControl, int grado, double[] nudos, double u)
        {
            int n = puntosControl.Count - 1;
            if (n < 0) return PointF.Empty;
            if (grado < 1) return puntosControl[0];

            int m = nudos.Length - 1;
            int k = -1;

            if (Math.Abs(u - nudos[m]) < 1e-12)
            {
                k = n;
            }
            else
            {
                for (int i = 0; i < nudos.Length - 1; i++)
                {
                    if (u >= nudos[i] && u < nudos[i + 1])
                    {
                        k = i;
                        break;
                    }
                }
            }

            if (k == -1)
            {
                k = Math.Max(grado, Math.Min(n, nudos.Length - grado - 2));
            }

            PointF[] d = new PointF[grado + 1];
            for (int j = 0; j <= grado; j++)
            {
                int idx = k - grado + j;
                idx = Math.Max(0, Math.Min(n, idx));
                d[j] = puntosControl[idx];
            }

            for (int r = 1; r <= grado; r++)
            {
                for (int j = grado; j >= r; j--)
                {
                    int idx_k_p_j = k - grado + j;
                    double denom = nudos[idx_k_p_j + grado - r + 1] - nudos[idx_k_p_j];
                    double alpha = 0.0;
                    if (Math.Abs(denom) > 1e-12)
                    {
                        alpha = (u - nudos[idx_k_p_j]) / denom;
                    }

                    d[j] = new PointF(
                        (float)((1.0 - alpha) * d[j - 1].X + alpha * d[j].X),
                        (float)((1.0 - alpha) * d[j - 1].Y + alpha * d[j].Y)
                    );
                }
            }

            return d[grado];
        }

        public static List<PointF> EvaluarCurva(List<PointF> puntosControl, int grado, int muestras)
        {
            var resultado = new List<PointF>();
            if (puntosControl == null || puntosControl.Count == 0) return resultado;
            if (grado < 1) grado = 1;
            if (grado >= puntosControl.Count) grado = puntosControl.Count - 1;
            if (muestras < 2) muestras = 2;

            double[] nudos = GenerarNudosClamped(puntosControl.Count, grado);

            double uInicio = nudos[grado];
            double uFin = nudos[puntosControl.Count];

            for (int i = 0; i <= muestras; i++)
            {
                double t = (double)i / muestras;
                double u = uInicio + t * (uFin - uInicio);
                var p = DeBoor(puntosControl, grado, nudos, u);
                resultado.Add(p);
            }

            return resultado;
        }

        public static PointF DeCasteljau(List<PointF> puntosControl, double t)
        {
            if (puntosControl == null || puntosControl.Count == 0) return PointF.Empty;
            int n = puntosControl.Count;
            PointF[] pts = new PointF[n];
            for (int i = 0; i < n; i++) pts[i] = puntosControl[i];

            for (int r = 1; r < n; r++)
            {
                for (int i = 0; i < n - r; i++)
                {
                    pts[i] = new PointF(
                        (float)((1 - t) * pts[i].X + t * pts[i + 1].X),
                        (float)((1 - t) * pts[i].Y + t * pts[i + 1].Y)
                    );
                }
            }

            return pts[0];
        }

        public static List<PointF> EvaluarBezier(List<PointF> puntosControl, int muestras)
        {
            var resultado = new List<PointF>();
            if (puntosControl == null || puntosControl.Count == 0) return resultado;
            if (muestras < 2) muestras = 2;

            for (int i = 0; i <= muestras; i++)
            {
                double t = (double)i / muestras;
                var p = DeCasteljau(puntosControl, t);
                resultado.Add(p);
            }

            return resultado;
        }
    }
}
